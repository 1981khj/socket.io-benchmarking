<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>drewww/socket.io-benchmarking @ GitHub</title>

  <style type="text/css">
    body {
      margin-top: 1.0em;
      background-color: #E3EDED;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #0A0A10;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
    h1 { font-size: 3.8em; color: #515171; margin-bottom: 3px; }
    h1 .small { font-size: 0.4em; }
    h1 a { text-decoration: none }
    h2 { font-size: 1.5em; color: #515171; }
    h3 { text-align: center; color: #515171; }
    a { color: #515171; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    .download { float: right; }
    pre { background: #000; color: #fff; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
  </style>
</head>

<body>
  <a href="https://github.com/drewww/socket.io-benchmarking"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="container">

    <h1><a href="https://github.com/drewww/socket.io-benchmarking">Practical socket.io Benchmarking</a>
      <span class="small">by Drew Harry</span></h1>


	<p>

    <p>I've had lots of fun making prototypes in <a href="http://nodejs.org">nodejs</a> with <a href="http://http://socket.io/">socket.io</a>. But I've kinda felt lost in thinking about the performance of the server if I ever needed to scale something up. What, exactly, is costly? What's the bottleneck in performance? A few potential limiting factors came to mind:</p>

<ul>
	<li>holding lots of connections open simultaneously</li>
	<li>receiving lots of messages</li>
	<li>sending lots of messages</li>
</ul>

<p>There's been some nice work at figuring out how many connections <a href="http://blog.mixu.net/2011/11/22/performance-benchmarking-socket-io-0-8-7-0-7-11-and-0-6-17-and-nodes-native-tcp/">a server might be able to support</a>, but that only knocks out one of our potential bottlenecks. How do we figure out whether holding simultaneous connections open is the most intensive part of scaling up a socket.io server? And if the bottleneck is message-related, what's a good rule of thumb for when you're going to need to move beyond a single-process to scale?</p>

<p>This is not a comparative analysis. I'm not trying to argue that node or socket.io are better or worse than some other technique (although I will muse on the tradeoffs at the end of the piece), simply trying to give people architecting socket.io applications a sense of when they might start hitting limits and what the behavior is when you're close to the limit. I should also say that I'm not a veteran node programmer, so I apologize if there are any glaring mistakes or I'm making arguments that are already obvious to everyone. They weren't obvious to me starting out, and I had a hard time finding the information I wanted elsewhere, so here I am.</p>

<p><b>TL;DR</b> If you want to bypass the full analysis, heres the punchline: I found that the main performance bottleneck is <i>sending</i> messages, not holding connections open or receiving messages. On a 3.3 MHz Xeon X5470 using one core, the max messages-sent-per-second rate is around 8,000&ndash;10,000 depending on the concurrency level.</p>
	
<h2>Test Setup</h2>




<p>	As I was trying to evaluate the performance of a prototype for a <a href="http://roar.media.mit.edu">new project of mine</a> I was having a hard time figuring out what exactly the bottlenecks in my system were going to be. There's been some nice work in this space already, Peter Griess has a handy tool called <a href="http://blog.std.in/2010/09/24/benchmarking-web-socket-servers/">wsbench</a> </p>
    

    

    

    
    

    <h2>Download</h2>
    <p>
		All the code I used to generate this data is available in the github repository. It's not particularly useable or well documented, but it did work long enough for me to collect the data. Please let me know if you discover any egregious oversights in the methodology that the code reveals and I'll update this article accordingly. You can download the whole repository in either 
      <a href="https://github.com/drewww/socket.io-benchmarking/zipball/master">zip</a> or
      <a href="https://github.com/drewww/socket.io-benchmarking/tarball/master">tar formats.
    </p>
    <p>You can also clone the project with <a href="http://git-scm.com">Git</a>
      by running:
      <pre>$ git clone git://github.com/drewww/socket.io-benchmarking</pre>

	I would of course be deeply grateful for any updates or edits to the code. It might be worth turning the core client-side tester into a general purpose socket.io load testing tool aimed for practical, real-life use patterns at high concurrency. 
    </p>
	

  </div>

<script type=\"text/javascript\">
var gaJsHost = ((\"https:\" == document.location.protocol) ? \"https://ssl.\" : \"http://www.\");
document.write(unescape(\"%3Cscript src='\" + gaJsHost + \"google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E\"));
</script>
<script type=\"text/javascript\">
try {
var pageTracker = _gat._getTracker("UA-841537-7");
pageTracker._trackPageview();
} catch(err) {}</script>"
</body>
</html>
